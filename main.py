from numpy import zeros, flipud
import pygame
import math

WIDTH = 600
HEIGHT = 600
SIZE = (WIDTH, HEIGHT)
DIMENSIONS = (10, 10)
SURFACE = DIMENSIONS[0]*DIMENSIONS[1]
PIECESNUMBER = int((DIMENSIONS[0]-2)/2)
SQUAREWIDTH = int(WIDTH / DIMENSIONS[0])
SQUAREHEIGHT = int(HEIGHT / DIMENSIONS[1])
BLACKPIECE = pygame.image.load("b_piece.png")
WHITEPIECE = pygame.image.load("w_piece.png")
#colors
#         R   G   B
LIGHT = (254,206,158)
DARK  = (209,139, 70)
BLACK = (  0,  0,  0)
WHITE = (255,255,255)

def createBoard(dimensions):
    return flipud(zeros(dimensions))

def fillBoard(board):
    coords = createBoardCoords()
    c = 0
    for x in range(DIMENSIONS[0]):
        for y in range(DIMENSIONS[1]):
            if board[x][y] == 1:
                screen.blit(BLACKPIECE, [coords[c][0]+5, coords[c][1]+2])
            elif board[x][y] == 2:
                screen.blit(WHITEPIECE, [coords[c][0]+5, coords[c][1]+2])
            c += 1
    

#return the coords for very case (in this case there is 10 columns and 10 rows so 100 case so 100 array of x,y coords)
def createBoardCoords():
    board_coords = []
    y = 0
    while y < HEIGHT:
        for x in range(0, HEIGHT, SQUAREWIDTH):
            board_coords.append([x, y])
        y += SQUAREWIDTH
    return board_coords


#only used when starting a nex game
#fill the board with 1 for black pieces and 2 for white pieces and keep the zeros for the empty cases
def initBoard(board):
    mod = (0, 1)
    inv = True
    for x in range(PIECESNUMBER):
        inv = int(not inv)
        for y in range(DIMENSIONS[1]):
            if y % 2 != inv:
                board[x][y] = 2
    
    for x in range(DIMENSIONS[0]-1, PIECESNUMBER+1, -1):
        inv = int(not inv)
        for y in range(DIMENSIONS[1]):
            if y % 2 == inv:
                board[x][y] = 1

#return possible moves for a selected piece for a player
#return false in case of impossible move (max left or right, same piece of playing player, max front moves)
def checkMove(board, coords, player):
    current = board[coords[0]][coords[1]]
    if current == 1 or current == 2:
        if current == 2:
            x = coords[0]+1
            ly = coords[1]-1
            ry = coords[1]+1
            #print("Condition (L): ", ly in range(10) and ry not in range(10) and int(board[x][ly]) != player)
            #print("Condition (R): ", ly not in range(10) and ry in range(10) and int(board[x][ry]) != player)
            if x in range(10):
                if ly in range(10) and ry in range(10) and int(board[x][ly]) != player and int(board[x][ry]) != player:
                    return [[x, ly], [x, ry]]
                elif ly in range(10) and ry in range(10) and int(board[x][ly]) != player and int(board[x][ry]) == player:
                    return [[x, ly]]
                elif ly in range(10) and ry in range(10) and int(board[x][ly]) == player and int(board[x][ry]) != player:
                    return [[x, ry]]
                elif ly in range(10) and ry not in range(10) and int(board[x][ly]) != player:
                    return [[x, ly]]
                elif ly not in range(10) and ry in range(10) and int(board[x][ry]) != player:
                    return [[x, ry]]
                else:
                    return False
            else:
                return False
        else:
            x = coords[0]-1
            ly = coords[1]-1
            ry = coords[1]+1
            if x in range(10):
                if ly in range(10) and ry in range(10) and int(board[x][ly]) != player and int(board[x][ry]) != player:
                    return [[x, ly], [x, ry]]
                elif ly in range(10) and ry in range(10) and int(board[x][ly]) != player and int(board[x][ry]) == player:
                    return [[x, ly]]
                elif ly in range(10) and ry in range(10) and int(board[x][ly]) == player and int(board[x][ry]) != player:
                    return [[x, ry]]
                elif ly in range(10) and ry not in range(10) and int(board[x][ly]) != player:
                    return [[x, ly]]
                elif ly not in range(10) and ry in range(10) and int(board[x][ry]) != player:
                    return [[x, ry]]
                else:
                    return False
            else:
                return False

    else:
        return False

#move piece from origin(origin) selected position coords to choice(choice) selected coords from possible moves (moves) 
#generated by checkMoves function by changing the board(board) pirces numbers (1/2)
#return the choice coords (the new position of the poved piece) cz it will be used tu toggle player turn
def move(board, player, origin, moves, choice):
    print("Player: {0}".format(player))
    print("choice: {0}".format(choice))
    if not player:
        player = int(board[origin[0]][origin[1]])
    
    if player == 2:
        if moves:
            #if moves.__len__() == 1:
            #    if choice == moves[0]:
            #        board[origin[0]][origin[1]]  = 0
            #        board[choice[0]][choice[1]] = 2 #same as using moves in place of moves with double index
            #        return True
            #    else:
            #        return False
            #else:
            if choice in moves:
                board[origin[0]][origin[1]]  = 0
                board[choice[0]][choice[1]] = 2
                return choice
        else:
            return False
    elif player == 1:
        if moves:
            #if moves.__len__() == 1:
            #    if choice == moves[0]:
            #        board[origin[0]][origin[1]]  = 0
            #        board[choice[0]][choice[1]] = 1 #same as using choice in place of moves with single index
            #        return True
            #    else:
            #        return False
            #else:
            if choice in moves:
                board[origin[0]][origin[1]]  = 0
                board[choice[0]][choice[1]] = 1
                return choice
        else:
            return False

    


#draw board cases using coords created by createBoardCoords function
#draw 100 cases (in this case it's the board dimensions(10*10))
#draw the pieces depending on every piece reference number (1/2) using the fillBoard function
def drawBoard(board):
    coords = createBoardCoords()
    color = (DARK, LIGHT)
    color_inv = False
    row_inv = 1
    c = 0

    while c < coords.__len__():
        if row_inv > DIMENSIONS[0]:
            color_inv = not color_inv
            row_inv = 1
        pygame.draw.rect(screen, color[int(color_inv)], [coords[c][0], coords[c][1], SQUAREWIDTH, SQUAREHEIGHT])
        color_inv = not color_inv
        c += 1
        row_inv += 1
    fillBoard(board)
    pygame.display.update()

#toggler player turn (1/2)
def toggleTurn(board, pieceNewPos, player):
    if pieceNewPos:
        if board[pieceNewPos[0]][pieceNewPos[1]] == 1:
            return 2
        return 1
    else:
        return player


#select or deselect piece depending on player turn by chaging the piece reference number (1:3/2:4)
def toggleSelection(board, player, origin):
    if not player:
        player = int(board[origin[0]][origin[1]])
    
    if player == 1:
        
    elif player == 2:
        pass



        


#init pygame
pygame.init()
#set pygame window size (in px)
screen = pygame.display.set_mode(SIZE)
#set pygame window title
pygame.display.set_caption("Damme V1.0")
#set pygame window icon
pygame.display.set_icon(pygame.image.load("dames.ico"))

#loop controller
#exit the main loop if condition is True
gameEnd = False

#clock
#to control game speed
clock = pygame.time.Clock()


#change the screen color to LIGHT
#screen.fill(LIGHT) 


#create board matrix 
board = createBoard(DIMENSIONS)

#fill board with pieces refs (1/2 for black and white and 0 for empty cases)
initBoard(board)

#draw the cases and the pieces
drawBoard(board)



print(board)
possibleMoves = False
origin = []
player = None


#Game main loop
while not gameEnd:
    for e in pygame.event.get():
        if e.type == pygame.QUIT:
            gameEnd = True

        if e.type == pygame.MOUSEBUTTONDOWN:
            if not possibleMoves:
                posx = e.pos[0]
                posy = e.pos[1]
                x = int(math.floor(posx/SQUAREWIDTH))
                y = int(math.floor(posy/SQUAREHEIGHT))
                origin = [y, x] #reversed because of matrix behaviour
                possibleMoves = checkMove(board, [y, x], int(board[origin[0]][origin[1]]))
                print("origin: "+str(origin))
                print("possibleMoves: "+str(possibleMoves))
            else:
                posx = e.pos[0]
                posy = e.pos[1]
                x = int(math.floor(posx/SQUAREWIDTH))
                y = int(math.floor(posy/SQUAREHEIGHT))
                choice = [y, x]
                movedPiecePos = move(board, player, origin, possibleMoves, choice)
                print(board)
                drawBoard(board)
                #fillBoard(board)
                pygame.display.update()
                possibleMoves = False
                origin = []
                player = toggleTurn(board, movedPiecePos, player)
                print("Piece new position: ", movedPiecePos)
                print("Next player: ", player)

            

pygame.quit()